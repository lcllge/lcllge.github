<mxfile host="app.diagrams.net" modified="2024-04-30T03:10:49.984Z" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36 Edg/118.0.2088.57" etag="HR94zZeg-343_5gBVxBM" version="24.3.1" type="github">
  <diagram name="第 1 页" id="zpewmBza0FNkQy-Cuxgg">
    <mxGraphModel dx="2213" dy="1962" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <UserObject label="package com.example.myproject.auth;&#xa;&#xa;import com.github.benmanes.caffeine.cache.Cache;&#xa;import com.github.benmanes.caffeine.cache.Caffeine;&#xa;import jakarta.enterprise.context.ApplicationScoped;&#xa;import jakarta.inject.Singleton;&#xa;import org.eclipse.microprofile.config.inject.ConfigProperty;&#xa;&#xa;import java.util.concurrent.TimeUnit;&#xa;&#xa;/**&#xa; * @author Lanzhou&#xa; * @date 2024/3/29-15:54&#xa; * @since all right&#xa; */&#xa;@ApplicationScoped&#xa;public class AuthTokenCache {&#xa;&#xa;    @ConfigProperty(name = &quot;auth.token.expire.hour&quot;)&#xa;    Integer tokenExpireHour;&#xa;&#xa;    @Singleton&#xa;    public Cache authUserCache() {&#xa;        return Caffeine.newBuilder()&#xa;                // 设置最后一次写入或访问后经过固定时间过期&#xa;                .expireAfterWrite(tokenExpireHour, TimeUnit.HOURS)&#xa;                // 初始的缓存空间大小&#xa;                .initialCapacity(100)&#xa;                // 缓存的最大条数&#xa;                .maximumSize(1000)&#xa;                .build();&#xa;    }&#xa;&#xa;}" link="package com.example.myproject.auth;&#xa;&#xa;import com.github.benmanes.caffeine.cache.Cache;&#xa;import com.github.benmanes.caffeine.cache.Caffeine;&#xa;import jakarta.enterprise.context.ApplicationScoped;&#xa;import jakarta.inject.Singleton;&#xa;import org.eclipse.microprofile.config.inject.ConfigProperty;&#xa;&#xa;import java.util.concurrent.TimeUnit;&#xa;&#xa;/**&#xa; * @author Lanzhou&#xa; * @date 2024/3/29-15:54&#xa; * @since all right&#xa; */&#xa;@ApplicationScoped&#xa;public class AuthTokenCache {&#xa;&#xa;    @ConfigProperty(name = &quot;auth.token.expire.hour&quot;)&#xa;    Integer tokenExpireHour;&#xa;&#xa;    @Singleton&#xa;    public Cache authUserCache() {&#xa;        return Caffeine.newBuilder()&#xa;                // 设置最后一次写入或访问后经过固定时间过期&#xa;                .expireAfterWrite(tokenExpireHour, TimeUnit.HOURS)&#xa;                // 初始的缓存空间大小&#xa;                .initialCapacity(100)&#xa;                // 缓存的最大条数&#xa;                .maximumSize(1000)&#xa;                .build();&#xa;    }&#xa;&#xa;}" id="8X4-1tDAFazHf9m_EC3D-6">
          <mxCell style="text;whiteSpace=wrap;html=1;" parent="1" vertex="1">
            <mxGeometry x="440" y="-575" width="350" height="510" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="package com.example.myproject.auth;&#xa;&#xa;import com.example.myproject.entity.User;&#xa;import com.example.myproject.mapper.UserMapper;&#xa;import com.example.myproject.response.ResponseResult;&#xa;import com.github.benmanes.caffeine.cache.Cache;&#xa;import jakarta.enterprise.context.ApplicationScoped;&#xa;import jakarta.inject.Inject;&#xa;import jakarta.ws.rs.*;&#xa;import jakarta.ws.rs.core.Context;&#xa;import jakarta.ws.rs.core.HttpHeaders;&#xa;import jakarta.ws.rs.core.MediaType;&#xa;import lombok.extern.slf4j.Slf4j;&#xa;import org.eclipse.microprofile.config.inject.ConfigProperty;&#xa;&#xa;import java.time.LocalDateTime;&#xa;import java.util.Objects;&#xa;import java.util.UUID;&#xa;&#xa;/**&#xa; * @author Lanzhou&#xa; * @date 2024/3/19-17:06&#xa; * @since all right&#xa; */&#xa;@Slf4j&#xa;@Path(&quot;auth&quot;)&#xa;@ApplicationScoped&#xa;@Produces(MediaType.APPLICATION_JSON)&#xa;@Consumes(MediaType.APPLICATION_JSON)&#xa;public class AuthEndpoint {&#xa;&#xa;    @Inject&#xa;    UserMapper userMapper;&#xa;&#xa;    @Inject&#xa;    Cache authUserCache;&#xa;&#xa;    @ConfigProperty(name = &quot;auth.token.key&quot;)&#xa;    String authTokenKey;&#xa;    @ConfigProperty(name = &quot;auth.token.salt&quot;)&#xa;    String authTokenSalt;&#xa;    @ConfigProperty(name = &quot;auth.token.expire.hour&quot;)&#xa;    Integer tokenExpireHour;&#xa;&#xa;    // 获取当前用户信息&#xa;    @GET&#xa;    @Path(&quot;principal&quot;)&#xa;    @Consumes(MediaType.APPLICATION_JSON)&#xa;    public ResponseResult principal() {&#xa;        AuthUser auth = AuthUserContext.getLoginUser();&#xa;        return ResponseResult.success(auth);&#xa;    }&#xa;&#xa;    // 登入&#xa;    @POST&#xa;    @Path(&quot;login&quot;)&#xa;    @Produces(MediaType.APPLICATION_JSON)&#xa;    @Consumes(MediaType.APPLICATION_JSON)&#xa;    public ResponseResult login(LoginUserDTO login) {&#xa;        // 登入用户信息校验&#xa;        User user = userMapper.findByName(login.getUsername());&#xa;        if (Objects.isNull(user) || !user.getPassword().equals(login.getPassword())) {&#xa;            return ResponseResult.fail(&quot;当前用户名或密码错误, 请重新登入&quot;);&#xa;        }&#xa;        // 登入成功, 返回token&#xa;        LocalDateTime expire = LocalDateTime.now().plusHours(tokenExpireHour);&#xa;        AuthUser authUser = AuthUser.builder().id(user.getId()).name(user.getName())&#xa;                .role(user.getRole()).expire(expire).build();&#xa;        String tokenKey = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);&#xa;        // 系统存一份副本&#xa;        authUserCache.put(tokenKey, authUser);&#xa;        String token = TokenEncryptor.encrypt(tokenKey, authTokenSalt);&#xa;        return ResponseResult.success(token);&#xa;    }&#xa;&#xa;&#xa;    // 登入&#xa;    @POST&#xa;    @Path(&quot;auth-login&quot;)&#xa;    @Produces(MediaType.APPLICATION_JSON)&#xa;    @Consumes(MediaType.APPLICATION_JSON)&#xa;    public ResponseResult authLogin(LoginUserDTO login) {&#xa;        // 1. 通过用户名获取用户信息&#xa;        User user = userMapper.findByName(login.getUsername());&#xa;        // 2. 登入用户信息校验&#xa;        if (Objects.isNull(user) || !user.getPassword().equals(login.getPassword())) {&#xa;            return ResponseResult.fail(&quot;当前用户名或密码错误, 请重新登入&quot;);&#xa;        }&#xa;        // 3. 登入成功, 返回token给前台&#xa;        LocalDateTime expire = LocalDateTime.now().plusHours(tokenExpireHour);&#xa;        String token = user.getId() + &quot;@&quot; + expire;&#xa;        return ResponseResult.success(token);&#xa;    }&#xa;&#xa;&#xa;    // 登出&#xa;    @GET&#xa;    @Path(&quot;logout&quot;)&#xa;    @Consumes(MediaType.APPLICATION_JSON)&#xa;    public ResponseResult logout(@Context HttpHeaders uriInfo) {&#xa;        try {&#xa;            String authToken = uriInfo.getHeaderString(authTokenKey);&#xa;            String tokenVal = TokenEncryptor.decrypt(authToken, authTokenSalt);&#xa;            authUserCache.invalidate(tokenVal);&#xa;        } catch (NullPointerException e) {&#xa;            log.warn(&quot;当前用户信息已经清空, 用户标识不存在&quot;, e);&#xa;        } catch (RuntimeException e) {&#xa;            throw new RuntimeException(&quot;用户登出失败请稍后重试&quot;, e);&#xa;        }&#xa;        return ResponseResult.success(&quot;登出成功&quot;);&#xa;    }&#xa;&#xa;}" link="package com.example.myproject.auth;&#xa;&#xa;import com.example.myproject.entity.User;&#xa;import com.example.myproject.mapper.UserMapper;&#xa;import com.example.myproject.response.ResponseResult;&#xa;import com.github.benmanes.caffeine.cache.Cache;&#xa;import jakarta.enterprise.context.ApplicationScoped;&#xa;import jakarta.inject.Inject;&#xa;import jakarta.ws.rs.*;&#xa;import jakarta.ws.rs.core.Context;&#xa;import jakarta.ws.rs.core.HttpHeaders;&#xa;import jakarta.ws.rs.core.MediaType;&#xa;import lombok.extern.slf4j.Slf4j;&#xa;import org.eclipse.microprofile.config.inject.ConfigProperty;&#xa;&#xa;import java.time.LocalDateTime;&#xa;import java.util.Objects;&#xa;import java.util.UUID;&#xa;&#xa;/**&#xa; * @author Lanzhou&#xa; * @date 2024/3/19-17:06&#xa; * @since all right&#xa; */&#xa;@Slf4j&#xa;@Path(&quot;auth&quot;)&#xa;@ApplicationScoped&#xa;@Produces(MediaType.APPLICATION_JSON)&#xa;@Consumes(MediaType.APPLICATION_JSON)&#xa;public class AuthEndpoint {&#xa;&#xa;    @Inject&#xa;    UserMapper userMapper;&#xa;&#xa;    @Inject&#xa;    Cache authUserCache;&#xa;&#xa;    @ConfigProperty(name = &quot;auth.token.key&quot;)&#xa;    String authTokenKey;&#xa;    @ConfigProperty(name = &quot;auth.token.salt&quot;)&#xa;    String authTokenSalt;&#xa;    @ConfigProperty(name = &quot;auth.token.expire.hour&quot;)&#xa;    Integer tokenExpireHour;&#xa;&#xa;    // 获取当前用户信息&#xa;    @GET&#xa;    @Path(&quot;principal&quot;)&#xa;    @Consumes(MediaType.APPLICATION_JSON)&#xa;    public ResponseResult principal() {&#xa;        AuthUser auth = AuthUserContext.getLoginUser();&#xa;        return ResponseResult.success(auth);&#xa;    }&#xa;&#xa;    // 登入&#xa;    @POST&#xa;    @Path(&quot;login&quot;)&#xa;    @Produces(MediaType.APPLICATION_JSON)&#xa;    @Consumes(MediaType.APPLICATION_JSON)&#xa;    public ResponseResult login(LoginUserDTO login) {&#xa;        // 登入用户信息校验&#xa;        User user = userMapper.findByName(login.getUsername());&#xa;        if (Objects.isNull(user) || !user.getPassword().equals(login.getPassword())) {&#xa;            return ResponseResult.fail(&quot;当前用户名或密码错误, 请重新登入&quot;);&#xa;        }&#xa;        // 登入成功, 返回token&#xa;        LocalDateTime expire = LocalDateTime.now().plusHours(tokenExpireHour);&#xa;        AuthUser authUser = AuthUser.builder().id(user.getId()).name(user.getName())&#xa;                .role(user.getRole()).expire(expire).build();&#xa;        String tokenKey = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);&#xa;        // 系统存一份副本&#xa;        authUserCache.put(tokenKey, authUser);&#xa;        String token = TokenEncryptor.encrypt(tokenKey, authTokenSalt);&#xa;        return ResponseResult.success(token);&#xa;    }&#xa;&#xa;&#xa;    // 登入&#xa;    @POST&#xa;    @Path(&quot;auth-login&quot;)&#xa;    @Produces(MediaType.APPLICATION_JSON)&#xa;    @Consumes(MediaType.APPLICATION_JSON)&#xa;    public ResponseResult authLogin(LoginUserDTO login) {&#xa;        // 1. 通过用户名获取用户信息&#xa;        User user = userMapper.findByName(login.getUsername());&#xa;        // 2. 登入用户信息校验&#xa;        if (Objects.isNull(user) || !user.getPassword().equals(login.getPassword())) {&#xa;            return ResponseResult.fail(&quot;当前用户名或密码错误, 请重新登入&quot;);&#xa;        }&#xa;        // 3. 登入成功, 返回token给前台&#xa;        LocalDateTime expire = LocalDateTime.now().plusHours(tokenExpireHour);&#xa;        String token = user.getId() + &quot;@&quot; + expire;&#xa;        return ResponseResult.success(token);&#xa;    }&#xa;&#xa;&#xa;    // 登出&#xa;    @GET&#xa;    @Path(&quot;logout&quot;)&#xa;    @Consumes(MediaType.APPLICATION_JSON)&#xa;    public ResponseResult logout(@Context HttpHeaders uriInfo) {&#xa;        try {&#xa;            String authToken = uriInfo.getHeaderString(authTokenKey);&#xa;            String tokenVal = TokenEncryptor.decrypt(authToken, authTokenSalt);&#xa;            authUserCache.invalidate(tokenVal);&#xa;        } catch (NullPointerException e) {&#xa;            log.warn(&quot;当前用户信息已经清空, 用户标识不存在&quot;, e);&#xa;        } catch (RuntimeException e) {&#xa;            throw new RuntimeException(&quot;用户登出失败请稍后重试&quot;, e);&#xa;        }&#xa;        return ResponseResult.success(&quot;登出成功&quot;);&#xa;    }&#xa;&#xa;}" id="8X4-1tDAFazHf9m_EC3D-7">
          <mxCell style="text;whiteSpace=wrap;html=1;" parent="1" vertex="1">
            <mxGeometry x="440" y="430" width="450" height="1650" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="package com.example.myproject.auth; &#xa; &#xa;import lombok.Data; &#xa; &#xa;import java.io.Serializable; &#xa; &#xa;/** &#xa; * @author Lanzhou &#xa; * @date 2024/3/19-17:08 &#xa; * @since all right &#xa; */ &#xa;@Data &#xa;public class LoginUserDTO implements Serializable { &#xa; &#xa;    /** &#xa;     * 登入用户名 &#xa;     */ &#xa;    private String username; &#xa; &#xa;    /** &#xa;     * 登入用户明文密码 &#xa;     */ &#xa;    private String password; &#xa; &#xa;}" link="package com.example.myproject.auth; &#xa; &#xa;import lombok.Data; &#xa; &#xa;import java.io.Serializable; &#xa; &#xa;/** &#xa; * @author Lanzhou &#xa; * @date 2024/3/19-17:08 &#xa; * @since all right &#xa; */ &#xa;@Data &#xa;public class LoginUserDTO implements Serializable { &#xa; &#xa;    /** &#xa;     * 登入用户名 &#xa;     */ &#xa;    private String username; &#xa; &#xa;    /** &#xa;     * 登入用户明文密码 &#xa;     */ &#xa;    private String password; &#xa; &#xa;}" id="8X4-1tDAFazHf9m_EC3D-8">
          <mxCell style="text;whiteSpace=wrap;html=1;" parent="1" vertex="1">
            <mxGeometry x="750" y="-170" width="320" height="380" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="package com.example.myproject.auth;&#xa;&#xa;import java.util.Set;&#xa;&#xa;/**&#xa; * @author Lanzhou&#xa; * @date 2024/3/28-14:41&#xa; * @since all right&#xa; */&#xa;public interface AuthProvider {&#xa;&#xa;    /**&#xa;     * 是否可通行 - 判断当前角色是否可以使用这写路径&#xa;     *&#xa;     * @param role 角色&#xa;     * @param path 路径&#xa;     */&#xa;    void access(String role, String path);&#xa;&#xa;    /**&#xa;     * 是否可通行 - 判断当前角色是否可以使用这写路径&#xa;     *&#xa;     * @param resource 拥有的路径信息&#xa;     * @param path     路径&#xa;     */&#xa;    boolean access(Set resource, String path);&#xa;&#xa;}" link="package com.example.myproject.auth;&#xa;&#xa;import java.util.Set;&#xa;&#xa;/**&#xa; * @author Lanzhou&#xa; * @date 2024/3/28-14:41&#xa; * @since all right&#xa; */&#xa;public interface AuthProvider {&#xa;&#xa;    /**&#xa;     * 是否可通行 - 判断当前角色是否可以使用这写路径&#xa;     *&#xa;     * @param role 角色&#xa;     * @param path 路径&#xa;     */&#xa;    void access(String role, String path);&#xa;&#xa;    /**&#xa;     * 是否可通行 - 判断当前角色是否可以使用这写路径&#xa;     *&#xa;     * @param resource 拥有的路径信息&#xa;     * @param path     路径&#xa;     */&#xa;    boolean access(Set resource, String path);&#xa;&#xa;}" id="8X4-1tDAFazHf9m_EC3D-9">
          <mxCell style="text;whiteSpace=wrap;html=1;" parent="1" vertex="1">
            <mxGeometry x="440" width="300" height="430" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="package com.example.myproject.auth;&#xa;&#xa;import com.github.benmanes.caffeine.cache.Cache;&#xa;import jakarta.annotation.Priority;&#xa;import jakarta.inject.Inject;&#xa;import jakarta.ws.rs.Priorities;&#xa;import jakarta.ws.rs.container.ContainerRequestContext;&#xa;import jakarta.ws.rs.container.ContainerRequestFilter;&#xa;import jakarta.ws.rs.container.ContainerResponseContext;&#xa;import jakarta.ws.rs.container.ContainerResponseFilter;&#xa;import jakarta.ws.rs.ext.Provider;&#xa;import lombok.extern.slf4j.Slf4j;&#xa;import org.eclipse.microprofile.config.inject.ConfigProperty;&#xa;import org.springframework.util.StringUtils;&#xa;&#xa;import java.io.IOException;&#xa;import java.time.LocalDateTime;&#xa;import java.util.HashSet;&#xa;import java.util.List;&#xa;import java.util.Objects;&#xa;&#xa;/**&#xa; * ContainerRequestFilter在调用 JAX-RS 资源方法之前运行。 ContainerResponseFilter在调用 JAX-RS 资源方法之后运行&#xa; *&#xa; * @author Lanzhou&#xa; * @date 2024/3/11-14:58&#xa; * @since all right&#xa; */&#xa;@Slf4j&#xa;@Provider&#xa;@Priority(Priorities.USER + 10)&#xa;public class TokenAuthenticationFilter implements ContainerRequestFilter, ContainerResponseFilter {&#xa;&#xa;    /**&#xa;     * 全局后台路径忽略校验点&#xa;     * 可以设置忽略登入的URL信息&#xa;     */&#xa;    @ConfigProperty(name = &quot;auth.token.skip.path&quot;)&#xa;    List skipAuthPath;&#xa;    @ConfigProperty(name = &quot;auth.token.key&quot;)&#xa;    String authTokenKey;&#xa;    @ConfigProperty(name = &quot;auth.token.salt&quot;)&#xa;    String authTokenSalt;&#xa;    @ConfigProperty(name = &quot;auth.token.expire.hour&quot;)&#xa;    Integer tokenExpireHour;&#xa;&#xa;    @Inject&#xa;    Cache authUserCache;&#xa;&#xa;    @Inject&#xa;    AuthProvider authProvider;&#xa;&#xa;&#xa;    /**&#xa;     * 请求 - 过滤器&#xa;     * 流程:&#xa;     * 1. 判断是否不需要校验, 是:直接放行&#xa;     * 2. 校验用户Token, 正常格式: 用户Id|过期时间 -&amp;gt; Token-Key 缓存存储&#xa;     * 3. 将值设置进入ThreadLocal中, 这时因为ContainerRequestFilter在调用 JAX-RS 资源方法之前运行。&#xa;     * ContainerResponseFilter在调用 JAX-RS 资源方法之后运行, 因此在资源操作可以获取当当前登入用户信息&#xa;     * 4. 当响应数据响应之前会清空ThreadLocal中的用户值, 确保不会多余缓存&#xa;     *&#xa;     * @param requestContext 请求&#xa;     * @throws IOException e&#xa;     */&#xa;    @Override&#xa;    public void filter(ContainerRequestContext requestContext) throws IOException {&#xa;        // 放行过滤Url白名单, 非授权校验链接直接放行&#xa;        String path = requestContext.getUriInfo().getPath();&#xa;&#xa;        // 白名单路径全部放行&#xa;        boolean isAccess = authProvider.access(new HashSet&amp;lt;&amp;gt;(skipAuthPath), path);&#xa;        if (isAccess) {&#xa;            return;&#xa;        }&#xa;&#xa;        // 其他URL, 需要校验Token值&#xa;        String decryptToken = requestContext.getHeaderString(authTokenKey);&#xa;        if (!StringUtils.hasText(decryptToken)) {&#xa;            throw new RuntimeException(&quot;无登入信息, 请登入后重试&quot;);&#xa;        }&#xa;&#xa;        // 请求头中Token解析出真正的登入标识, 换取缓存中的用户&#xa;        AuthUser authUser;&#xa;        String token;&#xa;        try {&#xa;            token = TokenEncryptor.decrypt(decryptToken, authTokenSalt);&#xa;            authUser = authUserCache.getIfPresent(token);&#xa;        } catch (RuntimeException e) {&#xa;            throw new RuntimeException(&quot;无效登入信息, 请重新登入&quot;, e);&#xa;        }&#xa;&#xa;        if (Objects.isNull(authUser) || LocalDateTime.now().isAfter(authUser.getExpire())) {&#xa;            log.warn(&quot;用户信息已过期, 请重新登入, token: [{}]&quot;, token);&#xa;            throw new RuntimeException(&quot;用户信息已过期, 请重新登入&quot;);&#xa;        }&#xa;&#xa;        // 分角色授权认证 (不同角色可以设置不同的访问路径)&#xa;        authProvider.access(authUser.getRole(), path);&#xa;&#xa;        // 刷新登入时间 - 使用Token在最后一次访问时, 保持最大的登入时间 (先过期, 再重新设置值)&#xa;        LocalDateTime expire = LocalDateTime.now().plusHours(tokenExpireHour);&#xa;        authUser.setExpire(expire);&#xa;        authUserCache.invalidate(token);&#xa;        authUserCache.put(token, authUser);&#xa;        // 用户区域数据设置线程变量&#xa;        AuthUserContext.setLoginUser(authUser);&#xa;        log.debug(&quot;AuthUserContext.setLoginUser - user info [{}], Token Login Success!&quot;, authUser);&#xa;    }&#xa;&#xa;    /**&#xa;     * 响应过滤器&#xa;     * - 响应前台数据前, 直接将内存中当次操作的用户清除掉&#xa;     *&#xa;     * @param requestContext  请求&#xa;     * @param responseContext 响应&#xa;     * @throws IOException e&#xa;     */&#xa;    @Override&#xa;    public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext) throws IOException {&#xa;        // 运行结束后清除登入用户&#xa;        AuthUserContext.clear();&#xa;        log.debug(&quot;AuthUserContext.clear - 爱护爱护啊哈 Login user info is clear...done !&quot;);&#xa;    }&#xa;&#xa;}" link="package com.example.myproject.auth;&#xa;&#xa;import com.github.benmanes.caffeine.cache.Cache;&#xa;import jakarta.annotation.Priority;&#xa;import jakarta.inject.Inject;&#xa;import jakarta.ws.rs.Priorities;&#xa;import jakarta.ws.rs.container.ContainerRequestContext;&#xa;import jakarta.ws.rs.container.ContainerRequestFilter;&#xa;import jakarta.ws.rs.container.ContainerResponseContext;&#xa;import jakarta.ws.rs.container.ContainerResponseFilter;&#xa;import jakarta.ws.rs.ext.Provider;&#xa;import lombok.extern.slf4j.Slf4j;&#xa;import org.eclipse.microprofile.config.inject.ConfigProperty;&#xa;import org.springframework.util.StringUtils;&#xa;&#xa;import java.io.IOException;&#xa;import java.time.LocalDateTime;&#xa;import java.util.HashSet;&#xa;import java.util.List;&#xa;import java.util.Objects;&#xa;&#xa;/**&#xa; * ContainerRequestFilter在调用 JAX-RS 资源方法之前运行。 ContainerResponseFilter在调用 JAX-RS 资源方法之后运行&#xa; *&#xa; * @author Lanzhou&#xa; * @date 2024/3/11-14:58&#xa; * @since all right&#xa; */&#xa;@Slf4j&#xa;@Provider&#xa;@Priority(Priorities.USER + 10)&#xa;public class TokenAuthenticationFilter implements ContainerRequestFilter, ContainerResponseFilter {&#xa;&#xa;    /**&#xa;     * 全局后台路径忽略校验点&#xa;     * 可以设置忽略登入的URL信息&#xa;     */&#xa;    @ConfigProperty(name = &quot;auth.token.skip.path&quot;)&#xa;    List skipAuthPath;&#xa;    @ConfigProperty(name = &quot;auth.token.key&quot;)&#xa;    String authTokenKey;&#xa;    @ConfigProperty(name = &quot;auth.token.salt&quot;)&#xa;    String authTokenSalt;&#xa;    @ConfigProperty(name = &quot;auth.token.expire.hour&quot;)&#xa;    Integer tokenExpireHour;&#xa;&#xa;    @Inject&#xa;    Cache authUserCache;&#xa;&#xa;    @Inject&#xa;    AuthProvider authProvider;&#xa;&#xa;&#xa;    /**&#xa;     * 请求 - 过滤器&#xa;     * 流程:&#xa;     * 1. 判断是否不需要校验, 是:直接放行&#xa;     * 2. 校验用户Token, 正常格式: 用户Id|过期时间 -&amp;gt; Token-Key 缓存存储&#xa;     * 3. 将值设置进入ThreadLocal中, 这时因为ContainerRequestFilter在调用 JAX-RS 资源方法之前运行。&#xa;     * ContainerResponseFilter在调用 JAX-RS 资源方法之后运行, 因此在资源操作可以获取当当前登入用户信息&#xa;     * 4. 当响应数据响应之前会清空ThreadLocal中的用户值, 确保不会多余缓存&#xa;     *&#xa;     * @param requestContext 请求&#xa;     * @throws IOException e&#xa;     */&#xa;    @Override&#xa;    public void filter(ContainerRequestContext requestContext) throws IOException {&#xa;        // 放行过滤Url白名单, 非授权校验链接直接放行&#xa;        String path = requestContext.getUriInfo().getPath();&#xa;&#xa;        // 白名单路径全部放行&#xa;        boolean isAccess = authProvider.access(new HashSet&amp;lt;&amp;gt;(skipAuthPath), path);&#xa;        if (isAccess) {&#xa;            return;&#xa;        }&#xa;&#xa;        // 其他URL, 需要校验Token值&#xa;        String decryptToken = requestContext.getHeaderString(authTokenKey);&#xa;        if (!StringUtils.hasText(decryptToken)) {&#xa;            throw new RuntimeException(&quot;无登入信息, 请登入后重试&quot;);&#xa;        }&#xa;&#xa;        // 请求头中Token解析出真正的登入标识, 换取缓存中的用户&#xa;        AuthUser authUser;&#xa;        String token;&#xa;        try {&#xa;            token = TokenEncryptor.decrypt(decryptToken, authTokenSalt);&#xa;            authUser = authUserCache.getIfPresent(token);&#xa;        } catch (RuntimeException e) {&#xa;            throw new RuntimeException(&quot;无效登入信息, 请重新登入&quot;, e);&#xa;        }&#xa;&#xa;        if (Objects.isNull(authUser) || LocalDateTime.now().isAfter(authUser.getExpire())) {&#xa;            log.warn(&quot;用户信息已过期, 请重新登入, token: [{}]&quot;, token);&#xa;            throw new RuntimeException(&quot;用户信息已过期, 请重新登入&quot;);&#xa;        }&#xa;&#xa;        // 分角色授权认证 (不同角色可以设置不同的访问路径)&#xa;        authProvider.access(authUser.getRole(), path);&#xa;&#xa;        // 刷新登入时间 - 使用Token在最后一次访问时, 保持最大的登入时间 (先过期, 再重新设置值)&#xa;        LocalDateTime expire = LocalDateTime.now().plusHours(tokenExpireHour);&#xa;        authUser.setExpire(expire);&#xa;        authUserCache.invalidate(token);&#xa;        authUserCache.put(token, authUser);&#xa;        // 用户区域数据设置线程变量&#xa;        AuthUserContext.setLoginUser(authUser);&#xa;        log.debug(&quot;AuthUserContext.setLoginUser - user info [{}], Token Login Success!&quot;, authUser);&#xa;    }&#xa;&#xa;    /**&#xa;     * 响应过滤器&#xa;     * - 响应前台数据前, 直接将内存中当次操作的用户清除掉&#xa;     *&#xa;     * @param requestContext  请求&#xa;     * @param responseContext 响应&#xa;     * @throws IOException e&#xa;     */&#xa;    @Override&#xa;    public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext) throws IOException {&#xa;        // 运行结束后清除登入用户&#xa;        AuthUserContext.clear();&#xa;        log.debug(&quot;AuthUserContext.clear - 爱护爱护啊哈 Login user info is clear...done !&quot;);&#xa;    }&#xa;&#xa;}" id="8X4-1tDAFazHf9m_EC3D-10">
          <mxCell style="text;whiteSpace=wrap;html=1;" parent="1" vertex="1">
            <mxGeometry x="-140" y="-230" width="560" height="1910" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="package com.example.myproject.auth; &#xa; &#xa;import lombok.Builder; &#xa;import lombok.Data; &#xa; &#xa;import java.io.Serializable; &#xa;import java.time.LocalDateTime; &#xa; &#xa;/** &#xa; * @author Lanzhou &#xa; * @date 2024/3/19-16:34 &#xa; * @since all right &#xa; */ &#xa;@Data &#xa;@Builder &#xa;public class AuthUser implements Serializable { &#xa; &#xa;    /** &#xa;     * 用户Id &#xa;     */ &#xa;    private Long id; &#xa; &#xa;    /** &#xa;     * 用户名称 &#xa;     */ &#xa;    private String name; &#xa; &#xa;    /** &#xa;     * 用户角色 &#xa;     */ &#xa;    private String role; &#xa; &#xa;    /** &#xa;     * 登入过期时间 - 超过这个时间将会自动失效 &#xa;     */ &#xa;    private LocalDateTime expire; &#xa; &#xa;    // TODO 可以扩展一些字段, 比如当前用户所属公司, 部门等 &#xa;    // TODO 可以在TokenAuthenticationFilter#filter()的AuthUserContext.setLoginUser(loginUser)之前设置即可 &#xa; &#xa;}" link="package com.example.myproject.auth; &#xa; &#xa;import lombok.Builder; &#xa;import lombok.Data; &#xa; &#xa;import java.io.Serializable; &#xa;import java.time.LocalDateTime; &#xa; &#xa;/** &#xa; * @author Lanzhou &#xa; * @date 2024/3/19-16:34 &#xa; * @since all right &#xa; */ &#xa;@Data &#xa;@Builder &#xa;public class AuthUser implements Serializable { &#xa; &#xa;    /** &#xa;     * 用户Id &#xa;     */ &#xa;    private Long id; &#xa; &#xa;    /** &#xa;     * 用户名称 &#xa;     */ &#xa;    private String name; &#xa; &#xa;    /** &#xa;     * 用户角色 &#xa;     */ &#xa;    private String role; &#xa; &#xa;    /** &#xa;     * 登入过期时间 - 超过这个时间将会自动失效 &#xa;     */ &#xa;    private LocalDateTime expire; &#xa; &#xa;    // TODO 可以扩展一些字段, 比如当前用户所属公司, 部门等 &#xa;    // TODO 可以在TokenAuthenticationFilter#filter()的AuthUserContext.setLoginUser(loginUser)之前设置即可 &#xa; &#xa;}" id="8X4-1tDAFazHf9m_EC3D-11">
          <mxCell style="text;whiteSpace=wrap;html=1;" parent="1" vertex="1">
            <mxGeometry x="650" y="-1050" width="560" height="630" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="package com.example.myproject.auth;&#xa;&#xa;import jakarta.ws.rs.ext.Provider;&#xa;import org.springframework.util.CollectionUtils;&#xa;&#xa;import java.util.*;&#xa;&#xa;/**&#xa; * @author Lanzhou&#xa; * @date 2024/3/28-14:41&#xa; * @since all right&#xa; */&#xa;@Provider&#xa;public class PathAuthProvider implements AuthProvider {&#xa;&#xa;    /**&#xa;     * 授权资源字典&#xa;     */&#xa;    private static final Map&amp;gt; AUTH_RESOURCE_DICT = new HashMap&amp;lt;&amp;gt;();&#xa;&#xa;    /**&#xa;     * 不同角色权限集合&#xa;     */&#xa;    private static final Set ADMIN_RESOURCE = new HashSet&amp;lt;&amp;gt;(Arrays.asList(&quot;/auditlist/**&quot;, &quot;/userlist/**&quot;, &quot;/auth/**&quot;));&#xa;    private static final Set USER_RESOURCE = new HashSet&amp;lt;&amp;gt;(Arrays.asList(&quot;/checklist/**&quot;, &quot;/auth/**&quot;));&#xa;&#xa;    public PathAuthProvider() {&#xa;        AUTH_RESOURCE_DICT.put(&quot;admin&quot;, ADMIN_RESOURCE);&#xa;        AUTH_RESOURCE_DICT.put(&quot;user&quot;, USER_RESOURCE);&#xa;        // 下面这种不建议用, 最好还是英文标识&#xa;        AUTH_RESOURCE_DICT.put(&quot;管理员&quot;, ADMIN_RESOURCE);&#xa;        AUTH_RESOURCE_DICT.put(&quot;用户&quot;, USER_RESOURCE);&#xa;    }&#xa;&#xa;    /**&#xa;     * 是否可通行 - 判断当前角色是否可以使用这写路径&#xa;     *&#xa;     * @param role 角色&#xa;     * @param path 路径&#xa;     */&#xa;    public void access(String role, String path) {&#xa;        Set resource = AUTH_RESOURCE_DICT.get(role);&#xa;        if (CollectionUtils.isEmpty(resource) || !checkAuthPath(path, resource)) {&#xa;            throw new RuntimeException(&quot;当前角色暂无该权限, 请联系管理员获得该权限&quot;);&#xa;        }&#xa;    }&#xa;&#xa;    /**&#xa;     * 是否可通行 - 判断当前角色是否可以使用这写路径&#xa;     *&#xa;     * @param resource 拥有的路径资源&#xa;     * @param path     路径&#xa;     */&#xa;    public boolean access(Set resource, String path) {&#xa;        if (CollectionUtils.isEmpty(resource)) {&#xa;            return false;&#xa;        }&#xa;        return checkAuthPath(path, resource);&#xa;    }&#xa;&#xa;    /**&#xa;     * 判断路径是否匹配&#xa;     *&#xa;     * @param path     目标路径&#xa;     * @param resource 资源集合&#xa;     * @return 是否有权限&#xa;     */&#xa;    private boolean checkAuthPath(String path, Set resource) {&#xa;        for (String re : resource) {&#xa;            if (compareWithPath(path, re)) {&#xa;                return true;&#xa;            }&#xa;        }&#xa;        return false;&#xa;    }&#xa;&#xa;    /**&#xa;     * 是否匹配 - 匹配直接返回true&#xa;     *&#xa;     * @param source 源路径&#xa;     * @param target 目标路径&#xa;     * @return 是否匹配&#xa;     */&#xa;    private boolean compareWithPath(String source, String target) {&#xa;        // /a/b -&amp;gt; /a/** = true&#xa;        if (target.endsWith(&quot;/**&quot;)) {&#xa;            String prefix = target.replace(&quot;/**&quot;, &quot;&quot;);&#xa;            return source.startsWith(prefix);&#xa;        } else {&#xa;            // /a/c -&amp;gt; /a/d = false&#xa;            return source.equals(target);&#xa;        }&#xa;    }&#xa;&#xa;}" link="package com.example.myproject.auth;&#xa;&#xa;import jakarta.ws.rs.ext.Provider;&#xa;import org.springframework.util.CollectionUtils;&#xa;&#xa;import java.util.*;&#xa;&#xa;/**&#xa; * @author Lanzhou&#xa; * @date 2024/3/28-14:41&#xa; * @since all right&#xa; */&#xa;@Provider&#xa;public class PathAuthProvider implements AuthProvider {&#xa;&#xa;    /**&#xa;     * 授权资源字典&#xa;     */&#xa;    private static final Map&amp;gt; AUTH_RESOURCE_DICT = new HashMap&amp;lt;&amp;gt;();&#xa;&#xa;    /**&#xa;     * 不同角色权限集合&#xa;     */&#xa;    private static final Set ADMIN_RESOURCE = new HashSet&amp;lt;&amp;gt;(Arrays.asList(&quot;/auditlist/**&quot;, &quot;/userlist/**&quot;, &quot;/auth/**&quot;));&#xa;    private static final Set USER_RESOURCE = new HashSet&amp;lt;&amp;gt;(Arrays.asList(&quot;/checklist/**&quot;, &quot;/auth/**&quot;));&#xa;&#xa;    public PathAuthProvider() {&#xa;        AUTH_RESOURCE_DICT.put(&quot;admin&quot;, ADMIN_RESOURCE);&#xa;        AUTH_RESOURCE_DICT.put(&quot;user&quot;, USER_RESOURCE);&#xa;        // 下面这种不建议用, 最好还是英文标识&#xa;        AUTH_RESOURCE_DICT.put(&quot;管理员&quot;, ADMIN_RESOURCE);&#xa;        AUTH_RESOURCE_DICT.put(&quot;用户&quot;, USER_RESOURCE);&#xa;    }&#xa;&#xa;    /**&#xa;     * 是否可通行 - 判断当前角色是否可以使用这写路径&#xa;     *&#xa;     * @param role 角色&#xa;     * @param path 路径&#xa;     */&#xa;    public void access(String role, String path) {&#xa;        Set resource = AUTH_RESOURCE_DICT.get(role);&#xa;        if (CollectionUtils.isEmpty(resource) || !checkAuthPath(path, resource)) {&#xa;            throw new RuntimeException(&quot;当前角色暂无该权限, 请联系管理员获得该权限&quot;);&#xa;        }&#xa;    }&#xa;&#xa;    /**&#xa;     * 是否可通行 - 判断当前角色是否可以使用这写路径&#xa;     *&#xa;     * @param resource 拥有的路径资源&#xa;     * @param path     路径&#xa;     */&#xa;    public boolean access(Set resource, String path) {&#xa;        if (CollectionUtils.isEmpty(resource)) {&#xa;            return false;&#xa;        }&#xa;        return checkAuthPath(path, resource);&#xa;    }&#xa;&#xa;    /**&#xa;     * 判断路径是否匹配&#xa;     *&#xa;     * @param path     目标路径&#xa;     * @param resource 资源集合&#xa;     * @return 是否有权限&#xa;     */&#xa;    private boolean checkAuthPath(String path, Set resource) {&#xa;        for (String re : resource) {&#xa;            if (compareWithPath(path, re)) {&#xa;                return true;&#xa;            }&#xa;        }&#xa;        return false;&#xa;    }&#xa;&#xa;    /**&#xa;     * 是否匹配 - 匹配直接返回true&#xa;     *&#xa;     * @param source 源路径&#xa;     * @param target 目标路径&#xa;     * @return 是否匹配&#xa;     */&#xa;    private boolean compareWithPath(String source, String target) {&#xa;        // /a/b -&amp;gt; /a/** = true&#xa;        if (target.endsWith(&quot;/**&quot;)) {&#xa;            String prefix = target.replace(&quot;/**&quot;, &quot;&quot;);&#xa;            return source.startsWith(prefix);&#xa;        } else {&#xa;            // /a/c -&amp;gt; /a/d = false&#xa;            return source.equals(target);&#xa;        }&#xa;    }&#xa;&#xa;}" id="8X4-1tDAFazHf9m_EC3D-12">
          <mxCell style="text;whiteSpace=wrap;html=1;" parent="1" vertex="1">
            <mxGeometry x="1080" y="-1030" width="560" height="1420" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="package com.example.myproject.auth;&#xa;&#xa;/**&#xa; * @author Lanzhou&#xa; * @date 2024/3/19-16:16&#xa; * @since all right&#xa; */&#xa;public class AuthUserContext {&#xa;&#xa;    /**&#xa;     * 线程存储的用户信息&#xa;     * 只会在当前线程起作用&#xa;     */&#xa;    private static final ThreadLocal USER_THREAD_LOCAL = new ThreadLocal&amp;lt;&amp;gt;();&#xa;&#xa;    /**&#xa;     * 获取当前操作用户&#xa;     *&#xa;     * @return 操作用户&#xa;     */&#xa;    public static AuthUser getLoginUser() {&#xa;        return USER_THREAD_LOCAL.get();&#xa;    }&#xa;&#xa;    /**&#xa;     * 设置登入用户&#xa;     *&#xa;     * @param authUser 用户信息&#xa;     */&#xa;    public static void setLoginUser(AuthUser authUser) {&#xa;        USER_THREAD_LOCAL.set(authUser);&#xa;    }&#xa;&#xa;    /**&#xa;     * 情况当前线程的用户信息&#xa;     */&#xa;    public static void clear() {&#xa;        USER_THREAD_LOCAL.remove();&#xa;    }&#xa;&#xa;}" link="package com.example.myproject.auth;&#xa;&#xa;/**&#xa; * @author Lanzhou&#xa; * @date 2024/3/19-16:16&#xa; * @since all right&#xa; */&#xa;public class AuthUserContext {&#xa;&#xa;    /**&#xa;     * 线程存储的用户信息&#xa;     * 只会在当前线程起作用&#xa;     */&#xa;    private static final ThreadLocal USER_THREAD_LOCAL = new ThreadLocal&amp;lt;&amp;gt;();&#xa;&#xa;    /**&#xa;     * 获取当前操作用户&#xa;     *&#xa;     * @return 操作用户&#xa;     */&#xa;    public static AuthUser getLoginUser() {&#xa;        return USER_THREAD_LOCAL.get();&#xa;    }&#xa;&#xa;    /**&#xa;     * 设置登入用户&#xa;     *&#xa;     * @param authUser 用户信息&#xa;     */&#xa;    public static void setLoginUser(AuthUser authUser) {&#xa;        USER_THREAD_LOCAL.set(authUser);&#xa;    }&#xa;&#xa;    /**&#xa;     * 情况当前线程的用户信息&#xa;     */&#xa;    public static void clear() {&#xa;        USER_THREAD_LOCAL.remove();&#xa;    }&#xa;&#xa;}" id="8X4-1tDAFazHf9m_EC3D-13">
          <mxCell style="text;whiteSpace=wrap;html=1;" parent="1" vertex="1">
            <mxGeometry x="-360" y="-860" width="470" height="610" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="package com.example.myproject.auth;&#xa;&#xa;import javax.crypto.Cipher;&#xa;import javax.crypto.spec.IvParameterSpec;&#xa;import javax.crypto.spec.SecretKeySpec;&#xa;import java.nio.charset.StandardCharsets;&#xa;import java.util.Base64;&#xa;import java.util.Objects;&#xa;import java.util.Random;&#xa;&#xa;/**&#xa; * Token解码器, 可以自定义盐(必须十六位)&#xa; *&#xa; * @author Lanzhou&#xa; * @date 2024/3/19-17:00&#xa; * @since all right&#xa; */&#xa;public class TokenEncryptor {&#xa;&#xa;    /**&#xa;     * 加密模式之 ECB，算法/模式/补码方式&#xa;     */&#xa;    private static final String AES_ECB = &quot;AES/ECB/PKCS5Padding&quot;;&#xa;&#xa;    /**&#xa;     * 加密模式之 CBC，算法/模式/补码方式&#xa;     */&#xa;    private static final String AES_CBC = &quot;AES/CBC/PKCS5Padding&quot;;&#xa;&#xa;    /**&#xa;     * 加密模式之 CFB，算法/模式/补码方式&#xa;     */&#xa;    private static final String AES_CFB = &quot;AES/CFB/PKCS5Padding&quot;;&#xa;&#xa;    /**&#xa;     * AES 中的 IV 必须是 16 字节（128位）长&#xa;     */&#xa;    private static final Integer IV_LENGTH = 16;&#xa;&#xa;    /***&#xa;     * &lt;h2&gt;空校验&lt;/h2&gt;&#xa;     * @param str 需要判断的值&#xa;     */&#xa;    public static boolean isEmpty(Object str) {&#xa;        return null == str || &quot;&quot;.equals(str);&#xa;    }&#xa;&#xa;    /***&#xa;     * &lt;h2&gt;String 转 byte&lt;/h2&gt;&#xa;     * @param str 需要转换的字符串&#xa;     */&#xa;    public static byte[] getBytes(String str) {&#xa;        if (isEmpty(str)) {&#xa;            return null;&#xa;        }&#xa;&#xa;        try {&#xa;            return str.getBytes(StandardCharsets.UTF_8);&#xa;        } catch (Exception e) {&#xa;            throw new RuntimeException(e);&#xa;        }&#xa;    }&#xa;&#xa;    /***&#xa;     * &lt;h2&gt;初始化向量（IV），它是一个随机生成的字节数组，用于增加加密和解密的安全性&lt;/h2&gt;&#xa;     */&#xa;    public static String getIV() {&#xa;        String str = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;;&#xa;        Random random = new Random();&#xa;        StringBuilder sb = new StringBuilder();&#xa;        for (int i = 0; i &amp;lt; IV_LENGTH; i++) {&#xa;            int number = random.nextInt(str.length());&#xa;            sb.append(str.charAt(number));&#xa;        }&#xa;        return sb.toString();&#xa;    }&#xa;&#xa;    /***&#xa;     * &lt;h2&gt;获取一个 AES 密钥规范&lt;/h2&gt;&#xa;     */&#xa;    public static SecretKeySpec getSecretKeySpec(String key) {&#xa;        return new SecretKeySpec(Objects.requireNonNull(getBytes(key)), &quot;AES&quot;);&#xa;    }&#xa;&#xa;    /**&#xa;     * &lt;h2&gt;加密 - 模式 ECB&lt;/h2&gt;&#xa;     *&#xa;     * @param text 需要加密的文本内容&#xa;     * @param key  加密的密钥 key&#xa;     */&#xa;    public static String encrypt(String text, String key) {&#xa;        if (isEmpty(text) || isEmpty(key)) {&#xa;            return null;&#xa;        }&#xa;        try {&#xa;            // 创建AES加密器&#xa;            Cipher cipher = Cipher.getInstance(AES_ECB);&#xa;            SecretKeySpec secretKeySpec = getSecretKeySpec(key);&#xa;            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);&#xa;            // 加密字节数组&#xa;            byte[] encryptedBytes = cipher.doFinal(Objects.requireNonNull(getBytes(text)));&#xa;            // 将密文转换为 Base64 编码字符串&#xa;            return Base64.getEncoder().encodeToString(encryptedBytes);&#xa;        } catch (Exception e) {&#xa;            throw new RuntimeException(e);&#xa;        }&#xa;    }&#xa;&#xa;    /**&#xa;     * &lt;h2&gt;解密 - 模式 ECB&lt;/h2&gt;&#xa;     *&#xa;     * @param text 需要解密的文本内容&#xa;     * @param key  解密的密钥 key&#xa;     */&#xa;    public static String decrypt(String text, String key) {&#xa;        if (isEmpty(text) || isEmpty(key)) {&#xa;            return null;&#xa;        }&#xa;&#xa;        // 将密文转换为16字节的字节数组&#xa;        byte[] textBytes = Base64.getDecoder().decode(text);&#xa;        try {&#xa;            // 创建AES加密器&#xa;            Cipher cipher = Cipher.getInstance(AES_ECB);&#xa;            SecretKeySpec secretKeySpec = getSecretKeySpec(key);&#xa;            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);&#xa;            // 解密字节数组&#xa;            byte[] decryptedBytes = cipher.doFinal(textBytes);&#xa;            // 将明文转换为字符串&#xa;            return new String(decryptedBytes, StandardCharsets.UTF_8);&#xa;        } catch (Exception e) {&#xa;            throw new RuntimeException(e);&#xa;        }&#xa;    }&#xa;&#xa;    /**&#xa;     * &lt;h2&gt;加密 - 自定义加密模式&lt;/h2&gt;&#xa;     *&#xa;     * @param text 需要加密的文本内容&#xa;     * @param key  加密的密钥 key&#xa;     * @param iv   初始化向量&#xa;     * @param mode 加密模式&#xa;     */&#xa;    public static String encrypt(String text, String key, String iv, String mode) {&#xa;        if (isEmpty(text) || isEmpty(key) || isEmpty(iv)) {&#xa;            return null;&#xa;        }&#xa;&#xa;        try {&#xa;            // 创建AES加密器&#xa;            Cipher cipher = Cipher.getInstance(mode);&#xa;            SecretKeySpec secretKeySpec = getSecretKeySpec(key);&#xa;            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, new IvParameterSpec(Objects.requireNonNull(getBytes(iv))));&#xa;            // 加密字节数组&#xa;            byte[] encryptedBytes = cipher.doFinal(Objects.requireNonNull(getBytes(text)));&#xa;            // 将密文转换为 Base64 编码字符串&#xa;            return Base64.getEncoder().encodeToString(encryptedBytes);&#xa;        } catch (Exception e) {&#xa;            throw new RuntimeException(e);&#xa;        }&#xa;    }&#xa;&#xa;    /**&#xa;     * &lt;h2&gt;解密 - 自定义加密模式&lt;/h2&gt;&#xa;     *&#xa;     * @param text 需要解密的文本内容&#xa;     * @param key  解密的密钥 key&#xa;     * @param iv   初始化向量&#xa;     * @param mode 加密模式&#xa;     */&#xa;    public static String decrypt(String text, String key, String iv, String mode) {&#xa;        if (isEmpty(text) || isEmpty(key) || isEmpty(iv)) {&#xa;            return null;&#xa;        }&#xa;&#xa;        // 将密文转换为16字节的字节数组&#xa;        byte[] textBytes = Base64.getDecoder().decode(text);&#xa;        try {&#xa;            // 创建AES加密器&#xa;            Cipher cipher = Cipher.getInstance(mode);&#xa;            SecretKeySpec secretKeySpec = getSecretKeySpec(key);&#xa;            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, new IvParameterSpec(Objects.requireNonNull(getBytes(iv))));&#xa;            // 解密字节数组&#xa;            byte[] decryptedBytes = cipher.doFinal(textBytes);&#xa;            // 将明文转换为字符串&#xa;            return new String(decryptedBytes, StandardCharsets.UTF_8);&#xa;        } catch (Exception e) {&#xa;            throw new RuntimeException(e);&#xa;        }&#xa;    }&#xa;&#xa;    public static void main(String[] args) {&#xa;        String text = &quot;嗨，您好！&quot;;&#xa;        String key = &quot;woniucsdnvip8888&quot;; // 16字节的密钥&#xa;        String iv = getIV();&#xa;&#xa;        String encryptTextEBC = encrypt(text, key);&#xa;        System.out.println(&quot;EBC 加密后内容：&quot; + encryptTextEBC);&#xa;        System.out.println(&quot;EBC 解密后内容：&quot; + decrypt(encryptTextEBC, key));&#xa;        System.out.println();&#xa;&#xa;&#xa;        String encryptTextCBC = encrypt(text, key, iv, AES_CBC);&#xa;        System.out.println(&quot;CBC 加密IV：&quot; + iv);&#xa;        System.out.println(&quot;CBC 加密后内容：&quot; + encryptTextCBC);&#xa;        System.out.println(&quot;CBC 解密后内容：&quot; + decrypt(encryptTextCBC, key, iv, AES_CBC));&#xa;        System.out.println();&#xa;&#xa;        String encryptTextCFB = encrypt(text, key, iv, AES_CFB);&#xa;        System.out.println(&quot;CFB 加密IV：&quot; + iv);&#xa;        System.out.println(&quot;CFB 加密后内容：&quot; + encryptTextCFB);&#xa;        System.out.println(&quot;CFB 解密后内容：&quot; + decrypt(encryptTextCFB, key, iv, AES_CFB));&#xa;&#xa;    }&#xa;}" link="package com.example.myproject.auth;&#xa;&#xa;import javax.crypto.Cipher;&#xa;import javax.crypto.spec.IvParameterSpec;&#xa;import javax.crypto.spec.SecretKeySpec;&#xa;import java.nio.charset.StandardCharsets;&#xa;import java.util.Base64;&#xa;import java.util.Objects;&#xa;import java.util.Random;&#xa;&#xa;/**&#xa; * Token解码器, 可以自定义盐(必须十六位)&#xa; *&#xa; * @author Lanzhou&#xa; * @date 2024/3/19-17:00&#xa; * @since all right&#xa; */&#xa;public class TokenEncryptor {&#xa;&#xa;    /**&#xa;     * 加密模式之 ECB，算法/模式/补码方式&#xa;     */&#xa;    private static final String AES_ECB = &quot;AES/ECB/PKCS5Padding&quot;;&#xa;&#xa;    /**&#xa;     * 加密模式之 CBC，算法/模式/补码方式&#xa;     */&#xa;    private static final String AES_CBC = &quot;AES/CBC/PKCS5Padding&quot;;&#xa;&#xa;    /**&#xa;     * 加密模式之 CFB，算法/模式/补码方式&#xa;     */&#xa;    private static final String AES_CFB = &quot;AES/CFB/PKCS5Padding&quot;;&#xa;&#xa;    /**&#xa;     * AES 中的 IV 必须是 16 字节（128位）长&#xa;     */&#xa;    private static final Integer IV_LENGTH = 16;&#xa;&#xa;    /***&#xa;     * &lt;h2&gt;空校验&lt;/h2&gt;&#xa;     * @param str 需要判断的值&#xa;     */&#xa;    public static boolean isEmpty(Object str) {&#xa;        return null == str || &quot;&quot;.equals(str);&#xa;    }&#xa;&#xa;    /***&#xa;     * &lt;h2&gt;String 转 byte&lt;/h2&gt;&#xa;     * @param str 需要转换的字符串&#xa;     */&#xa;    public static byte[] getBytes(String str) {&#xa;        if (isEmpty(str)) {&#xa;            return null;&#xa;        }&#xa;&#xa;        try {&#xa;            return str.getBytes(StandardCharsets.UTF_8);&#xa;        } catch (Exception e) {&#xa;            throw new RuntimeException(e);&#xa;        }&#xa;    }&#xa;&#xa;    /***&#xa;     * &lt;h2&gt;初始化向量（IV），它是一个随机生成的字节数组，用于增加加密和解密的安全性&lt;/h2&gt;&#xa;     */&#xa;    public static String getIV() {&#xa;        String str = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;;&#xa;        Random random = new Random();&#xa;        StringBuilder sb = new StringBuilder();&#xa;        for (int i = 0; i &amp;lt; IV_LENGTH; i++) {&#xa;            int number = random.nextInt(str.length());&#xa;            sb.append(str.charAt(number));&#xa;        }&#xa;        return sb.toString();&#xa;    }&#xa;&#xa;    /***&#xa;     * &lt;h2&gt;获取一个 AES 密钥规范&lt;/h2&gt;&#xa;     */&#xa;    public static SecretKeySpec getSecretKeySpec(String key) {&#xa;        return new SecretKeySpec(Objects.requireNonNull(getBytes(key)), &quot;AES&quot;);&#xa;    }&#xa;&#xa;    /**&#xa;     * &lt;h2&gt;加密 - 模式 ECB&lt;/h2&gt;&#xa;     *&#xa;     * @param text 需要加密的文本内容&#xa;     * @param key  加密的密钥 key&#xa;     */&#xa;    public static String encrypt(String text, String key) {&#xa;        if (isEmpty(text) || isEmpty(key)) {&#xa;            return null;&#xa;        }&#xa;        try {&#xa;            // 创建AES加密器&#xa;            Cipher cipher = Cipher.getInstance(AES_ECB);&#xa;            SecretKeySpec secretKeySpec = getSecretKeySpec(key);&#xa;            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);&#xa;            // 加密字节数组&#xa;            byte[] encryptedBytes = cipher.doFinal(Objects.requireNonNull(getBytes(text)));&#xa;            // 将密文转换为 Base64 编码字符串&#xa;            return Base64.getEncoder().encodeToString(encryptedBytes);&#xa;        } catch (Exception e) {&#xa;            throw new RuntimeException(e);&#xa;        }&#xa;    }&#xa;&#xa;    /**&#xa;     * &lt;h2&gt;解密 - 模式 ECB&lt;/h2&gt;&#xa;     *&#xa;     * @param text 需要解密的文本内容&#xa;     * @param key  解密的密钥 key&#xa;     */&#xa;    public static String decrypt(String text, String key) {&#xa;        if (isEmpty(text) || isEmpty(key)) {&#xa;            return null;&#xa;        }&#xa;&#xa;        // 将密文转换为16字节的字节数组&#xa;        byte[] textBytes = Base64.getDecoder().decode(text);&#xa;        try {&#xa;            // 创建AES加密器&#xa;            Cipher cipher = Cipher.getInstance(AES_ECB);&#xa;            SecretKeySpec secretKeySpec = getSecretKeySpec(key);&#xa;            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);&#xa;            // 解密字节数组&#xa;            byte[] decryptedBytes = cipher.doFinal(textBytes);&#xa;            // 将明文转换为字符串&#xa;            return new String(decryptedBytes, StandardCharsets.UTF_8);&#xa;        } catch (Exception e) {&#xa;            throw new RuntimeException(e);&#xa;        }&#xa;    }&#xa;&#xa;    /**&#xa;     * &lt;h2&gt;加密 - 自定义加密模式&lt;/h2&gt;&#xa;     *&#xa;     * @param text 需要加密的文本内容&#xa;     * @param key  加密的密钥 key&#xa;     * @param iv   初始化向量&#xa;     * @param mode 加密模式&#xa;     */&#xa;    public static String encrypt(String text, String key, String iv, String mode) {&#xa;        if (isEmpty(text) || isEmpty(key) || isEmpty(iv)) {&#xa;            return null;&#xa;        }&#xa;&#xa;        try {&#xa;            // 创建AES加密器&#xa;            Cipher cipher = Cipher.getInstance(mode);&#xa;            SecretKeySpec secretKeySpec = getSecretKeySpec(key);&#xa;            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, new IvParameterSpec(Objects.requireNonNull(getBytes(iv))));&#xa;            // 加密字节数组&#xa;            byte[] encryptedBytes = cipher.doFinal(Objects.requireNonNull(getBytes(text)));&#xa;            // 将密文转换为 Base64 编码字符串&#xa;            return Base64.getEncoder().encodeToString(encryptedBytes);&#xa;        } catch (Exception e) {&#xa;            throw new RuntimeException(e);&#xa;        }&#xa;    }&#xa;&#xa;    /**&#xa;     * &lt;h2&gt;解密 - 自定义加密模式&lt;/h2&gt;&#xa;     *&#xa;     * @param text 需要解密的文本内容&#xa;     * @param key  解密的密钥 key&#xa;     * @param iv   初始化向量&#xa;     * @param mode 加密模式&#xa;     */&#xa;    public static String decrypt(String text, String key, String iv, String mode) {&#xa;        if (isEmpty(text) || isEmpty(key) || isEmpty(iv)) {&#xa;            return null;&#xa;        }&#xa;&#xa;        // 将密文转换为16字节的字节数组&#xa;        byte[] textBytes = Base64.getDecoder().decode(text);&#xa;        try {&#xa;            // 创建AES加密器&#xa;            Cipher cipher = Cipher.getInstance(mode);&#xa;            SecretKeySpec secretKeySpec = getSecretKeySpec(key);&#xa;            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, new IvParameterSpec(Objects.requireNonNull(getBytes(iv))));&#xa;            // 解密字节数组&#xa;            byte[] decryptedBytes = cipher.doFinal(textBytes);&#xa;            // 将明文转换为字符串&#xa;            return new String(decryptedBytes, StandardCharsets.UTF_8);&#xa;        } catch (Exception e) {&#xa;            throw new RuntimeException(e);&#xa;        }&#xa;    }&#xa;&#xa;    public static void main(String[] args) {&#xa;        String text = &quot;嗨，您好！&quot;;&#xa;        String key = &quot;woniucsdnvip8888&quot;; // 16字节的密钥&#xa;        String iv = getIV();&#xa;&#xa;        String encryptTextEBC = encrypt(text, key);&#xa;        System.out.println(&quot;EBC 加密后内容：&quot; + encryptTextEBC);&#xa;        System.out.println(&quot;EBC 解密后内容：&quot; + decrypt(encryptTextEBC, key));&#xa;        System.out.println();&#xa;&#xa;&#xa;        String encryptTextCBC = encrypt(text, key, iv, AES_CBC);&#xa;        System.out.println(&quot;CBC 加密IV：&quot; + iv);&#xa;        System.out.println(&quot;CBC 加密后内容：&quot; + encryptTextCBC);&#xa;        System.out.println(&quot;CBC 解密后内容：&quot; + decrypt(encryptTextCBC, key, iv, AES_CBC));&#xa;        System.out.println();&#xa;&#xa;        String encryptTextCFB = encrypt(text, key, iv, AES_CFB);&#xa;        System.out.println(&quot;CFB 加密IV：&quot; + iv);&#xa;        System.out.println(&quot;CFB 加密后内容：&quot; + encryptTextCFB);&#xa;        System.out.println(&quot;CFB 解密后内容：&quot; + decrypt(encryptTextCFB, key, iv, AES_CFB));&#xa;&#xa;    }&#xa;}" id="8X4-1tDAFazHf9m_EC3D-14">
          <mxCell style="text;whiteSpace=wrap;html=1;" parent="1" vertex="1">
            <mxGeometry x="-750" y="-950" width="560" height="3690" as="geometry" />
          </mxCell>
        </UserObject>
        <UserObject label="quarkus.datasource.db-kind=mysql &#xa;quarkus.hibernate-orm.log.sql=true &#xa;quarkus.datasource.jdbc.max-size=8 &#xa;quarkus.datasource.jdbc.min-size=2 &#xa; &#xa;quarkus.datasource.username=root &#xa;quarkus.datasource.password=123456 &#xa;quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/quarkus &#xa;quarkus.hibernate-orm.log.format-sql=false &#xa;quarkus.hibernate-orm.use_sql_comments=true &#xa; &#xa; &#xa;quarkus.log.level=DEBUG &#xa;quarkus.log.min-level=DEBUG &#xa;#quarkus.log.file.enable=true &#xa;#quarkus.log.file.encoding=UTF-8 &#xa; &#xa;#quarkus.hibernate-orm.database.generation=drop-and-create &#xa;quarkus.hibernate-orm.sql-load-script=import.sql &#xa; &#xa;# 上传后删除临时文件信息 &#xa;quarkus.http.body.delete-uploaded-files-on-end=true &#xa;# 禁止静态资源访问 &#xa;quarkus.http.static-resources.include-hidden=false &#xa;quarkus.http.static-resources.enable-range-support=false &#xa; &#xa;# 自定义配置信息 &#xa;auth.token.key=token &#xa;auth.token.salt=yt_house_quarkus &#xa;auth.token.expire.hour=2 &#xa;auth.token.skip.path=/,/auth/login,/demo/**,/multipart/** &#xa; &#xa;#跨域访问 &#xa;quarkus.http.cors=true &#xa;quarkus.http.cors.origins=http://localhost:5173" link="quarkus.datasource.db-kind=mysql &#xa;quarkus.hibernate-orm.log.sql=true &#xa;quarkus.datasource.jdbc.max-size=8 &#xa;quarkus.datasource.jdbc.min-size=2 &#xa; &#xa;quarkus.datasource.username=root &#xa;quarkus.datasource.password=123456 &#xa;quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/quarkus &#xa;quarkus.hibernate-orm.log.format-sql=false &#xa;quarkus.hibernate-orm.use_sql_comments=true &#xa; &#xa; &#xa;quarkus.log.level=DEBUG &#xa;quarkus.log.min-level=DEBUG &#xa;#quarkus.log.file.enable=true &#xa;#quarkus.log.file.encoding=UTF-8 &#xa; &#xa;#quarkus.hibernate-orm.database.generation=drop-and-create &#xa;quarkus.hibernate-orm.sql-load-script=import.sql &#xa; &#xa;# 上传后删除临时文件信息 &#xa;quarkus.http.body.delete-uploaded-files-on-end=true &#xa;# 禁止静态资源访问 &#xa;quarkus.http.static-resources.include-hidden=false &#xa;quarkus.http.static-resources.enable-range-support=false &#xa; &#xa;# 自定义配置信息 &#xa;auth.token.key=token &#xa;auth.token.salt=yt_house_quarkus &#xa;auth.token.expire.hour=2 &#xa;auth.token.skip.path=/,/auth/login,/demo/**,/multipart/** &#xa; &#xa;#跨域访问 &#xa;quarkus.http.cors=true &#xa;quarkus.http.cors.origins=http://localhost:5173" id="8X4-1tDAFazHf9m_EC3D-15">
          <mxCell style="text;whiteSpace=wrap;html=1;" parent="1" vertex="1">
            <mxGeometry x="-150" y="1780" width="380" height="530" as="geometry" />
          </mxCell>
        </UserObject>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
